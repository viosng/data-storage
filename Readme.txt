Здравствуйте, Илья Игоревич.

Архитектура базы:
	1)База разделена на шарды, заправляет ими балансер, все сидят на разных Thrift
	серверах. В файле "conf" задаются порты для серверов.
	2)Каждая шарда состоит из одного реального хранилища данных. Для ускорения чтения
	создаются копии этого хранилища в куче и они все синхронно изменяются при запросах.
Как это все работает:
	1)Record :
		Он сгенерирован Thrift'ом
	2)RecordList :
		Используется для сериализации/десериализации
	3)Storage :
		Обычное такое хранилище
	4)Shard :
		Я решил не делать кучу слейвов(в прошлый раз делал).
		Вместо этого для каждой шарды помимо мастера хранится еще и(Recovery):
			a)если шарда не успела закончить работу, то версию шарды до начала работы;
			б)если шарда закончила работу нормально, то просто копию мастера;
		Для мастера хранится файлов логов действий, которые на записались на диск.
		Для recovery хранится лог всех действий за один сеанс работы с базой(
			я предполагаю, что эти два файла будут хранится в надежной файловой системе).
		При инициализации шарды Recovery прогоняет свои логи, мастер - свои, если
			их хэши не совпадают(следовательно мастер повредился), то запишем хранилище Recovery в мастер.
		Каждая шарда лежит на своем Thrift сервере и реализует ShardService.
	5)Balancer :
		Лежит на своем Thrift сервере и реализует BalancerService.
		Самая главная его функция, помимо обработки запросов, это - нормализация бд:
			балансер определяет, в какую шарду перенаправить запрос по остатку от деления
			id на количество валидных шардов, поэтому при каждой инициализации балансер
			пробегает по все шардам(валидным) и если id у какой то записи не соответствует
			определенному для шарды остатку от деления, то эта записи перекидывается в
			нужное место.
			Получается, что  при падении балансера, база сможет жить дальше, просто
			нужно будет определить другой балансер.
		Балансер может убирать или добавлять какую-то шарду, если убирает, то все записи из
		убираемой шарды копируются в оставшиеся, при добавлении наоборот, какие-то записи
		добавляются в новую(все делается на основе нормализации).
		Если шарда не отвечает на запросы, то с ней в текущем сеансе работать не будут.
		Соответственно, действия, которые направлены на эту шарду сохраняются и воспроизводятся,
		когда она станет валидной.
		
Тестирование:
		Для тестирования у меня написано несколько классов. Так как база распределенная и
		многопоточная, то у обычного ее пользователя нету возможности управления балансером,
		только запросы(CommandLineClient), зато у AdminCommandLine есть!
		Работу с командной строкой лучше тестировать на AdminCommandLine(в main() - testAdminCommandLine()),
		а многопоточную работу с запросами из файлов - на CommandLineClient(testConcurrent(clientsCount, commandsCountForEachClient))
		
		Отключение/подключение шардов можно потестить на testAdminCommandLine().
		Симулировать НЕработу шарды можно так:
			в testAdminCommandLine() - закоментировать соответствующую строку с инициализацией шарды
				(теперь данные из нее нам недоступны)
			в testConcurrent - тоже самое, но в конструкторе TestDB.

Надеюсь, я все написал:)

P.S.
	1)файл для генерации трифтовых файлов также присутствует в архиве
	2)если при многопоточной работе будут ошибки, то сильно не ругайте, я тестил ее сквозь пальцы, писал ради интереса.
	3)в этом дз я немного отклонился от задания, надеюсь это не критично.
С уважением, Савельев Николай.
	
